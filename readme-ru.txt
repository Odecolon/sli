sli v0.1a - simple L interpreter by Odecolon

1. О программе

sli - интерпретатор простого скриптового языка L, созданного мной для встраивания в другие мои проекты. Поэтому интерпретатор помещён в отдельный модуль, написанный на FP, а sli - это маленькая консоль вокруг его (как ни странно, написана тоже на FP).

Сам язык описан в четвёртом разделе этого readme. Кроме того, в папке examples этого репозитория лежат примеры скриптов. 

2. Что нового?

В версии 0.1a был доработан парсер математических выражений.

3. Запуск и возможности

Чтобы выполнить скрипт из файла:

	sli файл_скрипта файл_лога(опционально)

В консоли можно попробовать использовать какие-нибудь команды языка - например, присвоить значение переменной. Для выхода используется команда 'exit'.

Собиралось и тестировалось в lazarus v1.8.0 c fpc 3.0.4 win32 под Win7.

4. О языке L 

L - скриптовый язык, предназначенный для встраивания куда-нибудь. Простой, примитивный, громоздкий и неочевидный. Процедурный, но не функциональный. Имееет только глобальные переменные и только целочисленную арифметику.

Примечание - если вы совершили ошибку или не использовали приведённые рекомендации, то интерпретатор может или вообще вылететь, или выдать совершенно непредсказуемый результат.

1) Алфавит.

Латинский алфавит A-Z, a-z и ", =, >, <, +, -, /, *, $, %, (, ), ., ,, -, _

В названиях переменных и процедур можно использовать только буквы латинского алфавита, цифры, дефис и нижнее подчёркивание. Язык регистронезависим.

Интерпретатор работает построчно: разбивает строку на отдельные лексемы, обрабатывает каждую из них препроцессором, а уже потом выполняет. Единой лексемой считается либо набор символов без пробелов - например, foo123; либо строка, ограниченная кавычками - например, "John Paul George Ringo". Очевидно, что названия переменных не должны быть строками в кавычках. 

2) Ключевые слова.

def, proc, var, end, if, loop, break, continue, outln, out, getln, get, del 

3) Операторы и выражения

Операторы препроцессора $ и % стоят в начале лексемы и обрабатывают её перед выполнением строки:

Оператор $ получает значение переменной: лексема $имя_переменной превращается в лексему значение_переменной, например, если foo = 2, то $foo преобразуется в 2.

Оператор % вычисляет выражение: "%2 + 2" преобразуется в "4"; математические операторы +, -, /, *, ), ( внутри таких выражений делают именно то, что вы подумали.

Логично, что если нужно обработать выражение с переменными, к каждой из них нужно применить $: например, если foo равна 2, то "% 2 * $foo" преобразуется в "4". 

На обычные строки в кавычках (не математические выражения) % применять не стоит.

Пример: если foo = 2, то строка: 

	def var bar = "% $foo * 10"
	
после обработки будет выглядеть так:

	def var bar = 20
	
и только после этого отправится на выполнение.

В инструкции if применяются операторы =, <, >, <=, >=, != с также очевидным значением. Операторы <, >, <=, >= применяются только к числам, операторы =, != - к числам и строкам. 

4) Синтаксис.

4-1) Переменные.

Все переменные глобальные и хранятся в памяти как строки, так что технически значения могут быть любыми, однако для вычислений доступна только целочисленная арифметика.

Объявляются так:

	def var имя_переменной
	def var имя_переменной = значение

Рекомендуется присваивать значения сразу при объявлении.

Присвоить значение можно и так:

	имя_переменной = выражение

Количество переменных ограничено, поэтому их можно удалять:

	del имя_переменной

4-2) Процедуры.

Объявляются так:

	def proc имя_процедуры

	тело_процедуры

	end def

Вызываются так:

	do имя_процедуры

Возврат осуществляется либо по достижению конца процедуры, либо с помощью инструкции return в любом месте процедуры.

Каждый скрипт обязан содержать процедуру main, так как выполнение скрипта начинается с неё, а возврат из неё означает окончание работы интерпретатора.

Вложенных вызовов также ограниченное количество.

4-3) Ввод и вывод.

В sli есть стандарт для вывода в консоль (без переноса на сл. строку и с переносом):

	out выражение
	outln выражение

И для ввода из консоли (без переноса на сл. строку и с переносом):

	get имя_переменной
	getln имя_переменной

4-4) Управляющие конструкции.

Условие выглядит так - тело условия выполняется, если истина (ни логических операторов, ни ветвлений не предусмотрено):

	if выражение_1 оператор выражение_2 then

	тело_условия

	end if

Бесконечный и безусловный цикл:

	loop

	тело_цикла

	end loop

Цикл можно прервать инструкцией break и прокрутить на следующую итерацию инструкцией continue.

Вложенных циклов также ограниченное количество.

5) Примеры.

Как выглядит helloworld (examples\hello.l):

	def proc main

		outln "Hello, world!"

	end def

Вычисление факториала (examples\factorial.l):

	def proc main

		def var n 
        	def var f = 0
        
		out "n = "
		getln n          
	        
		n = "% $n + 1" 
		f = 1          
	
		loop
	        
			if $n = 1 then
		      
				break
		
			end if       
		
			n = "% $n - 1"
			f = "% $f * $n"		
	
		end loop
	
		out "f = "
		outln $f   

	end def
